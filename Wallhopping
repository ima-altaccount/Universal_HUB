local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wallhop state
local wallhopEnabled = false
local isShiftLock = false

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "UnHub"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 300, 0, 260)
frame.Position = UDim2.new(0.5, -150, 0.5, -130)
frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
frame.BorderSizePixel = 0
frame.ClipsDescendants = true
frame.Parent = screenGui

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 12)
uiCorner.Parent = frame

local uiStroke = Instance.new("UIStroke")
uiStroke.Color = Color3.fromRGB(60, 60, 60)
uiStroke.Transparency = 0.6
uiStroke.Thickness = 1.5
uiStroke.Parent = frame

-- Close button as X (FIXED: aspect constraint + centering + smaller size)
local closeButton = Instance.new("TextButton")
closeButton.Name = "Close"
closeButton.Size = UDim2.new(0, 32, 0, 32)
closeButton.Position = UDim2.new(1, -38, 0, 4)  -- top-right, inset
closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeButton.BorderSizePixel = 0
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.Font = Enum.Font.GothamBold
closeButton.TextSize = 20  -- Reduced to prevent clipping in circle
closeButton.TextXAlignment = Enum.TextXAlignment.Center
closeButton.TextYAlignment = Enum.TextYAlignment.Center
closeButton.ZIndex = 10
closeButton.Parent = frame

local closeUICorner = Instance.new("UICorner")
closeUICorner.CornerRadius = UDim.new(1, 0)  -- full circle
closeUICorner.Parent = closeButton

-- Force perfect square → fixes text rendering issues with full UICorner
local aspectConstraint = Instance.new("UIAspectRatioConstraint")
aspectConstraint.AspectRatio = 1
aspectConstraint.Parent = closeButton

-- Hover effect
closeButton.MouseEnter:Connect(function()
    closeButton.BackgroundColor3 = Color3.fromRGB(255, 70, 70)
    closeButton.Size = UDim2.new(0, 36, 0, 36)
    closeButton.Position = UDim2.new(1, -40, 0, 2)
end)

closeButton.MouseLeave:Connect(function()
    closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    closeButton.Size = UDim2.new(0, 32, 0, 32)
    closeButton.Position = UDim2.new(1, -38, 0, 4)
end)

-- Click: delete GUI
closeButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

-- Title Bar (adjusted slightly for close button space)
local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 36)
titleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
titleBar.BorderSizePixel = 0
titleBar.Parent = frame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 12)
titleCorner.Parent = titleBar

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -50, 1, 0)
titleLabel.Position = UDim2.new(0, 12, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Universal Hub — Wallhop V1.01"
titleLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 16
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.TextYAlignment = Enum.TextYAlignment.Center
titleLabel.Parent = titleBar

-- Dragging logic
local dragging, dragStart, startPos, dragInput = false, nil, nil, nil

local function updateDrag(input)
    if not dragging then return end
    local delta = input.Position - dragStart
    frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = frame.Position
        local conn; conn = input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
                conn:Disconnect()
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input == dragInput or input.UserInputType == Enum.UserInputType.Touch) then
        updateDrag(input)
    end
end)

-- Shift Lock detection
UserInputService:GetPropertyChangedSignal("MouseBehavior"):Connect(function()
    isShiftLock = (UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter)
end)
isShiftLock = (UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter)

-- Status label
local statusLabel = Instance.new("TextLabel")
statusLabel.Size = UDim2.new(0, 220, 0, 40)
statusLabel.Position = UDim2.new(0.5, -110, 0, 45)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "Wallhop OFF"
statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
statusLabel.Font = Enum.Font.GothamBold
statusLabel.TextSize = 20
statusLabel.TextXAlignment = Enum.TextXAlignment.Center
statusLabel.Parent = frame

local labelStroke = Instance.new("UIStroke")
labelStroke.Color = Color3.fromRGB(0, 0, 0)
labelStroke.Transparency = 0.4
labelStroke.Thickness = 1.2
labelStroke.Parent = statusLabel

-- Info label
local infoLabel = Instance.new("TextLabel")
infoLabel.Size = UDim2.new(0, 280, 0, 30)
infoLabel.Position = UDim2.new(0.5, -140, 0, 90)
infoLabel.BackgroundTransparency = 1
infoLabel.Text = "Press SPACE near a wall!"
infoLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
infoLabel.Font = Enum.Font.Gotham
infoLabel.TextSize = 14
infoLabel.TextXAlignment = Enum.TextXAlignment.Center
infoLabel.Parent = frame

-- Toggle button
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 220, 0, 44)
toggleButton.Position = UDim2.new(0.5, -110, 0, 130)
toggleButton.BackgroundColor3 = Color3.fromRGB(0, 120, 215)
toggleButton.BorderSizePixel = 0
toggleButton.Text = "Activate Wallhop"
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Font = Enum.Font.GothamSemibold
toggleButton.TextSize = 17
toggleButton.Parent = frame

local btnCorner = Instance.new("UICorner")
btnCorner.CornerRadius = UDim.new(0, 10)
btnCorner.Parent = toggleButton

local btnStroke = Instance.new("UIStroke")
btnStroke.Color = Color3.fromRGB(0, 80, 150)
btnStroke.Transparency = 0.3
btnStroke.Thickness = 1.2
btnStroke.Parent = toggleButton

-- Fade-in animation
frame.BackgroundTransparency = 1
uiStroke.Transparency = 1

for _, obj in frame:GetDescendants() do
    if obj:IsA("GuiObject") then
        obj.BackgroundTransparency = 1
        if obj:IsA("TextLabel") or obj:IsA("TextButton") then
            obj.TextTransparency = 1
        end
        if obj:IsA("UIStroke") then
            obj.Transparency = 1
        end
    end
end

local fadeInfo = TweenInfo.new(0.65, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)

TweenService:Create(frame, fadeInfo, {BackgroundTransparency = 0}):Play()
TweenService:Create(uiStroke, fadeInfo, {Transparency = 0.6}):Play()
TweenService:Create(titleBar, fadeInfo, {BackgroundTransparency = 0}):Play()

task.delay(0.12, function()
    for _, obj in frame:GetDescendants() do
        if obj:IsA("TextLabel") or obj:IsA("TextButton") then
            TweenService:Create(obj, fadeInfo, {TextTransparency = 0}):Play()
        end
        if obj:IsA("UIStroke") then
            local t = (obj == labelStroke and 0.4) or (obj == btnStroke and 0.3) or 0.6
            TweenService:Create(obj, fadeInfo, {Transparency = t}):Play()
        end
    end
end)

-- Wallhop raycast & logic
local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Exclude

local function getWallRaycastResult()
    local character = player.Character
    if not character then return nil end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return nil end

    raycastParams.FilterDescendantsInstances = {character}

    local directions = {
        humanoidRootPart.CFrame.LookVector,
        -humanoidRootPart.CFrame.LookVector,
        humanoidRootPart.CFrame.RightVector,
        -humanoidRootPart.CFrame.RightVector
    }

    local detectionDistance = 2.2
    local closestHit, minDistance = nil, detectionDistance + 1

    for _, direction in directions do
        local result = Workspace:Raycast(
            humanoidRootPart.Position,
            direction * detectionDistance,
            raycastParams
        )
        if result and result.Distance < minDistance then
            minDistance = result.Distance
            closestHit = result
        end
    end

    return closestHit
end

UserInputService.JumpRequest:Connect(function()
    if not wallhopEnabled then return end

    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local camera = Workspace.CurrentCamera

    if not (humanoid and rootPart and camera) then return end
    if humanoid.Health <= 0 then return end

    local wallRayResult = getWallRaycastResult()
    if not wallRayResult then return end

    wallhopEnabled = false
    task.delay(0.25, function() wallhopEnabled = true end)

    local wallNormal = wallRayResult.Normal
    local horizontalWallNormal = Vector3.new(wallNormal.X, 0, wallNormal.Z).Unit

    if horizontalWallNormal.Magnitude < 0.1 then
        horizontalWallNormal = (rootPart.CFrame.LookVector * Vector3.new(1,0,1)).Unit
        if horizontalWallNormal.Magnitude < 0.1 then
            horizontalWallNormal = Vector3.new(0,0,-1)
        end
    end

    local baseDirectionAwayFromWall = horizontalWallNormal

    local cameraLook = camera.CFrame.LookVector
    local horizontalCameraLook = Vector3.new(cameraLook.X, 0, cameraLook.Z).Unit

    if horizontalCameraLook.Magnitude < 0.1 then
        horizontalCameraLook = baseDirectionAwayFromWall
    end

    local maxInfluenceAngle = math.rad(45)
    local dot = math.clamp(baseDirectionAwayFromWall:Dot(horizontalCameraLook), -1, 1)
    local angleBetween = math.acos(dot)
    local cross = baseDirectionAwayFromWall:Cross(horizontalCameraLook)
    local rotationSign = math.sign(cross.Y)

    local actualInfluenceAngle = math.min(angleBetween, maxInfluenceAngle)
    local adjustmentRotation = CFrame.Angles(0, actualInfluenceAngle * rotationSign, 0)

    local initialTargetLookDirection = (adjustmentRotation * baseDirectionAwayFromWall).Unit

    -- Skip snap/rotation in shift lock
    if not isShiftLock then
        rootPart.CFrame = CFrame.lookAt(rootPart.Position, rootPart.Position + initialTargetLookDirection)
    end

    task.wait(0.025)

    if humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

-- Toggle button logic
toggleButton.MouseButton1Click:Connect(function()
    wallhopEnabled = not wallhopEnabled

    if wallhopEnabled then
        statusLabel.Text = "Wallhop ON"
        statusLabel.TextColor3 = Color3.fromRGB(80, 255, 80)
        toggleButton.Text = "Deactivate Wallhop"
        toggleButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    else
        statusLabel.Text = "Wallhop OFF"
        statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
        toggleButton.Text = "Activate Wallhop"
        toggleButton.BackgroundColor3 = Color3.fromRGB(0, 120, 215)
    end
end)

toggleButton.MouseEnter:Connect(function()
    toggleButton.BackgroundColor3 = wallhopEnabled and Color3.fromRGB(220, 70, 70) or Color3.fromRGB(0, 140, 240)
end)

toggleButton.MouseLeave:Connect(function()
    toggleButton.BackgroundColor3 = wallhopEnabled and Color3.fromRGB(200, 50, 50) or Color3.fromRGB(0, 120, 215)
end)
